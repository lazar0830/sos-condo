

import React, { useState, useMemo } from 'react';
import type { MaintenanceTask, Building, ServiceProvider, ServiceRequest } from '../types';
import { TaskStatus, Recurrence } from '../types';
import { TASK_STATUSES } from '../constants';
import useLocalStorage from '../hooks/useLocalStorage';
import CreateRequestModal from './CreateRequestModal';
import ConfirmationModal from './ConfirmationModal';

interface MaintenanceTasksViewProps {
  tasks: MaintenanceTask[];
  buildings: Building[];
  providers: ServiceProvider[];
  onAddTask: () => void;
  onEditTask: (task: MaintenanceTask) => void;
  onDeleteTask: (taskId: string) => void;
  // FIX: Aligned the onAddServiceRequest prop type with the handler in App.tsx
  // to accept a request object that includes a status but omits properties
  // that are generated by the handler itself (id, comments, documents, statusHistory).
  onAddServiceRequest: (request: Omit<ServiceRequest, 'id' | 'comments' | 'documents' | 'statusHistory'>) => void;
}

const statusColorMap: { [key in TaskStatus]: string } = {
  [TaskStatus.New]: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200',
  [TaskStatus.Sent]: 'bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300',
  [TaskStatus.OnHold]: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300',
  [TaskStatus.Completed]: 'bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300',
};

const specialtyColors = ['bg-sky-100 text-sky-800 dark:bg-sky-900/50 dark:text-sky-300','bg-amber-100 text-amber-800 dark:bg-amber-900/50 dark:text-amber-300','bg-rose-100 text-rose-800 dark:bg-rose-900/50 dark:text-rose-300','bg-fuchsia-100 text-fuchsia-800 dark:bg-fuchsia-900/50 dark:text-fuchsia-300','bg-cyan-100 text-cyan-800 dark:bg-cyan-900/50 dark:text-cyan-300','bg-lime-100 text-lime-800 dark:bg-lime-900/50 dark:text-lime-300','bg-violet-100 text-violet-800 dark:bg-violet-900/50 dark:text-violet-300','bg-emerald-100 text-emerald-800 dark:bg-emerald-900/50 dark:text-emerald-300','bg-indigo-100 text-indigo-800 dark:bg-indigo-900/50 dark:text-indigo-300','bg-teal-100 text-teal-800 dark:bg-teal-900/50 dark:text-teal-300','bg-pink-100 text-pink-800 dark:bg-pink-900/50 dark:text-pink-300','bg-orange-100 text-orange-800 dark:bg-orange-900/50 dark:text-orange-300'];
const getSpecialtyColor = (specialty: string) => {
  if (!specialty) return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
  let hash = 0;
  for (let i = 0; i < specialty.length; i++) {
    hash = specialty.charCodeAt(i) + ((hash << 5) - hash);
  }
  const index = Math.abs(hash % specialtyColors.length);
  return specialtyColors[index];
};


// A reusable component to render the table for a set of tasks
const TaskTable: React.FC<{ 
  tasks: MaintenanceTask[], 
  onEditTask: (task: MaintenanceTask) => void, 
  providers: ServiceProvider[],
  onOpenCreateRequest: (task: MaintenanceTask) => void,
  onOpenDelete: (task: MaintenanceTask) => void,
}> = ({ tasks, onEditTask, providers, onOpenCreateRequest, onOpenDelete }) => {
  const sortedTasks = [...tasks].sort((a, b) => {
    // Determine the master ID for each task. For a master, it's its own ID. For an instance, it's recurringTaskId.
    const masterIdA = a.recurringTaskId || a.id;
    const masterIdB = b.recurringTaskId || b.id;

    // 1. Primary sort: Group by master task.
    if (masterIdA.localeCompare(masterIdB) !== 0) {
      return masterIdA.localeCompare(masterIdB);
    }

    // They belong to the same master group.
    // 2. Secondary sort: Master task comes before its instances.
    // A master task has no recurringTaskId.
    if (!a.recurringTaskId && b.recurringTaskId) return -1; // a is master, b is instance
    if (a.recurringTaskId && !b.recurringTaskId) return 1;  // a is instance, b is master

    // 3. Tertiary sort: Sort instances by date.
    if (a.taskDate && b.taskDate) {
        return new Date(a.taskDate).getTime() - new Date(b.taskDate).getTime();
    }
    
    return 0; // Should not be reached if data is consistent
  });

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700 table-fixed">
        <thead className="bg-gray-50/50 dark:bg-gray-700/50">
          <tr>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Task</th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-40">Specialty</th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-48">Date</th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-48">Provider</th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-24">Cost</th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-32">Status</th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider w-48">Actions</th>
          </tr>
        </thead>
        <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
          {sortedTasks.map(task => {
            const provider = providers.find(p => p.id === task.providerId);
            const isMasterRecurring = task.recurrence !== Recurrence.OneTime;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const isOverdue = task.taskDate ? (new Date(task.taskDate + 'T12:00:00Z') < today && task.status !== TaskStatus.Completed) : false;
            
            return (
              <tr key={task.id} className={`hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors duration-150 ${task.recurringTaskId ? 'bg-blue-50/30 dark:bg-blue-900/20' : ''} ${isOverdue ? 'bg-red-50/50 dark:bg-red-900/20' : ''}`}>
                <td onClick={() => onEditTask(task)} className="px-6 py-4 cursor-pointer">
                  <div className="flex items-center space-x-2">
                    <div className={`text-sm font-medium break-words ${task.recurringTaskId ? 'pl-4 text-gray-700 dark:text-gray-300' : 'text-gray-900 dark:text-gray-100'}`}>{task.name}</div>
                    {isOverdue && <span className="px-2 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300">Overdue</span>}
                  </div>
                  <div className={`text-sm text-gray-500 dark:text-gray-400 ${task.recurringTaskId ? 'pl-4' : ''}`}>{task.recurrence}</div>
                </td>
                <td onClick={() => onEditTask(task)} className="px-6 py-4 whitespace-nowrap text-sm cursor-pointer">
                  <span className={`px-2.5 py-0.5 rounded-full text-xs font-medium ${getSpecialtyColor(task.specialty)}`}>{task.specialty}</span>
                </td>
                <td onClick={() => onEditTask(task)} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 font-medium cursor-pointer">
                  {task.taskDate && new Date(task.taskDate + 'T12:00:00Z').toLocaleDateString()}
                  {isMasterRecurring && task.startDate && task.endDate && 
                    `${new Date(task.startDate + 'T12:00:00Z').toLocaleDateString()} - ${new Date(task.endDate + 'T12:00:00Z').toLocaleDateString()}`
                  }
                </td>
                <td onClick={() => onEditTask(task)} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 cursor-pointer">{provider?.name || 'Not Assigned'}</td>
                <td onClick={() => onEditTask(task)} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 cursor-pointer">{task.cost ? `$${task.cost.toFixed(2)}` : 'N/A'}</td>
                <td onClick={() => onEditTask(task)} className="px-6 py-4 whitespace-nowrap text-sm cursor-pointer">
                  <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${statusColorMap[task.status]}`}>
                    {task.status}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                  <div className="flex items-center space-x-2">
                    <button 
                      onClick={(e) => { e.stopPropagation(); onOpenCreateRequest(task); }} 
                      disabled={isMasterRecurring}
                      className="px-3 py-1 text-xs rounded-md text-primary-700 bg-primary-100 hover:bg-primary-200 dark:text-primary-300 dark:bg-primary-900/50 dark:hover:bg-primary-900 disabled:bg-gray-100 disabled:text-gray-400 disabled:cursor-not-allowed whitespace-nowrap"
                    >
                      Create Service Request
                    </button>
                    <button 
                      onClick={(e) => { e.stopPropagation(); onOpenDelete(task); }} 
                      className="p-1.5 text-gray-400 hover:bg-red-50 dark:hover:bg-red-900/20 hover:text-red-600 dark:hover:text-red-300 rounded-full transition-colors" 
                      aria-label={`Delete ${task.name}`}
                    >
                      <svg className="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" />
                      </svg>
                    </button>
                  </div>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
};

interface Filters {
  selectedBuildingIds: string[];
  selectedStatuses: TaskStatus[];
  selectedProviderIds: string[];
  startDate: string;
  endDate: string;
}

const MaintenanceTasksView: React.FC<MaintenanceTasksViewProps> = ({ tasks, buildings, providers, onAddTask, onEditTask, onDeleteTask, onAddServiceRequest }) => {
  const [filtersVisible, setFiltersVisible] = useState(false);
  const [filters, setFilters] = useLocalStorage<Filters>('maintenanceTasksFilters', {
    selectedBuildingIds: [],
    selectedStatuses: [],
    selectedProviderIds: [],
    startDate: '',
    endDate: '',
  });

  const [taskForRequest, setTaskForRequest] = useState<MaintenanceTask | null>(null);
  const [deletingTask, setDeletingTask] = useState<MaintenanceTask | null>(null);

  const filteredTasks = useMemo(() => {
    return tasks.filter(task => {
      if (filters.selectedBuildingIds.length > 0 && !filters.selectedBuildingIds.includes(task.buildingId)) {
        return false;
      }
      if (filters.selectedStatuses.length > 0 && !filters.selectedStatuses.includes(task.status)) {
        return false;
      }
      if (filters.selectedProviderIds.length > 0 && !(task.providerId && filters.selectedProviderIds.includes(task.providerId))) {
        return false;
      }
      
      const taskStart = task.taskDate ? new Date(task.taskDate + 'T12:00:00Z') : (task.startDate ? new Date(task.startDate + 'T12:00:00Z') : null);
      const taskEnd = task.taskDate ? new Date(task.taskDate + 'T12:00:00Z') : (task.endDate ? new Date(task.endDate + 'T12:00:00Z') : null);

      if (!taskStart) return true;

      const filterStart = filters.startDate ? new Date(filters.startDate + 'T12:00:00Z') : null;
      const filterEnd = filters.endDate ? new Date(filters.endDate + 'T12:00:00Z') : null;

      if (filterStart && taskEnd && taskEnd < filterStart) return false;
      if (filterEnd && taskStart > filterEnd) return false;
      
      return true;
    });
  }, [tasks, filters]);

  const handleResetFilters = () => {
    setFilters({
      selectedBuildingIds: [],
      selectedStatuses: [],
      selectedProviderIds: [],
      startDate: '',
      endDate: '',
    });
    setFiltersVisible(false);
  };
  
  const handleMultiSelectChange = (key: 'selectedBuildingIds' | 'selectedStatuses' | 'selectedProviderIds', value: string) => {
    setFilters(prev => {
        const currentValues = prev[key] as string[];
        const newValues = currentValues.includes(value)
            ? currentValues.filter(v => v !== value)
            : [...currentValues, value];
        return { ...prev, [key]: newValues as any };
    });
  };

  const removeFilter = (key: keyof Filters, valueToRemove?: string) => {
    setFilters(prev => {
        if (key === 'startDate' || key === 'endDate') {
            return { ...prev, [key]: '' };
        }
        const currentValues = prev[key as 'selectedBuildingIds' | 'selectedStatuses' | 'selectedProviderIds'];
        if (Array.isArray(currentValues) && valueToRemove) {
            return { ...prev, [key]: currentValues.filter(v => v !== valueToRemove) };
        }
        return prev;
    });
  };

  const hasActiveFilters = 
    filters.selectedBuildingIds.length > 0 ||
    filters.selectedStatuses.length > 0 ||
    filters.selectedProviderIds.length > 0 ||
    filters.startDate !== '' ||
    filters.endDate !== '';

  const getBuildingName = (buildingId: string) => buildings.find(b => b.id === buildingId)?.name || 'Unknown Property';
  const getProviderName = (providerId: string) => providers.find(p => p.id === providerId)?.name || 'Unknown Provider';

  const groupTasksByProperty = (tasksToGroup: MaintenanceTask[]) => {
    return tasksToGroup.reduce((acc, task) => {
        const buildingId = task.buildingId;
        if (!acc[buildingId]) {
            acc[buildingId] = [];
        }
        acc[buildingId].push(task);
        return acc;
    }, {} as Record<string, MaintenanceTask[]>);
  };

  const oneTimeTasks = filteredTasks.filter(t => t.recurrence === Recurrence.OneTime && !t.recurringTaskId);
  const recurringTasks = filteredTasks.filter(t => t.recurrence !== Recurrence.OneTime || !!t.recurringTaskId);

  const groupedOneTimeTasks = groupTasksByProperty(oneTimeTasks);
  const groupedRecurringTasks = groupTasksByProperty(recurringTasks);

  const handleConfirmDelete = () => {
    if (deletingTask) {
        onDeleteTask(deletingTask.id);
        setDeletingTask(null);
    }
  };

  const confirmDeleteMessage = deletingTask?.recurrence !== Recurrence.OneTime
    ? "This is a master recurring task. Deleting it will also remove all of its scheduled occurrences. This action cannot be undone."
    : `Are you sure you want to permanently delete the task "${deletingTask?.name}"?`;
  
  const buildingForRequest = taskForRequest ? buildings.find(b => b.id === taskForRequest.buildingId) : null;

  const TaskSection: React.FC<{title: string, groupedTasks: Record<string, MaintenanceTask[]>}> = ({title, groupedTasks}) => (
    <section>
      <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4 pb-2 border-b-2 border-primary-200 dark:border-primary-500/30">{title}</h3>
      {Object.keys(groupedTasks).length > 0 ? (
        <div className="space-y-6">
          {Object.entries(groupedTasks).map(([buildingId, propertyTasks]) => (
            <div key={buildingId} className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
              <h4 className="px-6 py-3 bg-gray-50 dark:bg-gray-700/50 text-lg font-semibold text-gray-700 dark:text-gray-200 border-b dark:border-gray-700">{getBuildingName(buildingId)}</h4>
              <TaskTable 
                tasks={propertyTasks} 
                onEditTask={onEditTask} 
                providers={providers} 
                onOpenCreateRequest={setTaskForRequest}
                onOpenDelete={setDeletingTask}
              />
            </div>
          ))}
        </div>
      ) : (
        <div className="text-center py-10 bg-white dark:bg-gray-800 rounded-lg border-2 border-dashed border-gray-300 dark:border-gray-600">
          <h4 className="text-md font-medium text-gray-800 dark:text-gray-200">No {title.toLowerCase()} found.</h4>
          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">Try adjusting your filters or adding new tasks.</p>
        </div>
      )}
    </section>
  );
  
  const FilterPill: React.FC<{ onRemove: () => void, children: React.ReactNode }> = ({ onRemove, children }) => (
    <span className="inline-flex items-center gap-x-1.5 py-1.5 px-3 rounded-full text-xs font-medium bg-primary-100 text-primary-800 dark:bg-primary-900/50 dark:text-primary-300">
      {children}
      <button type="button" onClick={onRemove} className="flex-shrink-0 h-4 w-4 rounded-full inline-flex items-center justify-center text-primary-600 dark:text-primary-300 hover:bg-primary-200 dark:hover:bg-primary-900 hover:text-primary-700 dark:hover:text-primary-200 focus:outline-none focus:bg-primary-700 focus:text-white">
        <span className="sr-only">Remove filter</span>
        <svg className="h-3 w-3" stroke="currentColor" fill="none" viewBox="0 0 8 8">
            <path strokeLinecap="round" strokeWidth="1.5" d="M1 1l6 6m0-6L1 7" />
        </svg>
      </button>
    </span>
  );

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-3xl font-bold text-gray-900 dark:text-primary-400 mb-2">Maintenance Tasks</h2>
          <p className="text-lg text-gray-500 dark:text-gray-400">View and manage all scheduled tasks across your properties.</p>
        </div>
        <button
          onClick={onAddTask}
          className="px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
        >
          Add New Task
        </button>
      </div>

      <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <button
          onClick={() => setFiltersVisible(!filtersVisible)}
          className="w-full flex justify-between items-center text-left text-lg font-semibold text-gray-700 dark:text-gray-200"
        >
          <span>Filter Tasks</span>
          <svg className={`w-5 h-5 text-gray-500 dark:text-gray-400 transform transition-transform ${filtersVisible ? 'rotate-180' : ''}`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
          </svg>
        </button>
        {filtersVisible && (
          <div className="mt-4 pt-4 border-t dark:border-gray-700">
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">By Property</label>
                  <div className="space-y-2 max-h-40 overflow-y-auto pr-2">
                    {buildings.map(b => (
                      <div key={b.id} className="flex items-center">
                        <input id={`prop-${b.id}`} type="checkbox" checked={filters.selectedBuildingIds.includes(b.id)} onChange={() => handleMultiSelectChange('selectedBuildingIds', b.id)} className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500" />
                        <label htmlFor={`prop-${b.id}`} className="ml-2 block text-sm text-gray-900 dark:text-gray-200">{b.name}</label>
                      </div>
                    ))}
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">By Status</label>
                  <div className="space-y-2">
                    {TASK_STATUSES.map(s => (
                      <div key={s} className="flex items-center">
                        {/* FIX: Cast enum value 's' to string to satisfy the function signature. */}
                        <input id={`status-${s}`} type="checkbox" checked={filters.selectedStatuses.includes(s)} onChange={() => handleMultiSelectChange('selectedStatuses', s as string)} className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500" />
                        <label htmlFor={`status-${s}`} className="ml-2 block text-sm text-gray-900 dark:text-gray-200">{s}</label>
                      </div>
                    ))}
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">By Provider</label>
                  <div className="space-y-2 max-h-40 overflow-y-auto pr-2">
                    {providers.map(p => (
                      <div key={p.id} className="flex items-center">
                        <input id={`prov-${p.id}`} type="checkbox" checked={filters.selectedProviderIds.includes(p.id)} onChange={() => handleMultiSelectChange('selectedProviderIds', p.id)} className="h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500" />
                        <label htmlFor={`prov-${p.id}`} className="ml-2 block text-sm text-gray-900 dark:text-gray-200">{p.name}</label>
                      </div>
                    ))}
                  </div>
                </div>
                <div>
                  <label htmlFor="startDate" className="block text-sm font-medium text-gray-700 dark:text-gray-300">By Date Range</label>
                  <input type="date" name="startDate" id="startDate" value={filters.startDate} onChange={e => setFilters(prev => ({ ...prev, startDate: e.target.value }))} className="mt-1 block w-full input" />
                  <label htmlFor="endDate" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mt-2">to</label>
                  <input type="date" name="endDate" id="endDate" value={filters.endDate} onChange={e => setFilters(prev => ({ ...prev, endDate: e.target.value }))} className="mt-1 block w-full input" />
                </div>
            </div>
            <div className="mt-6 pt-4 border-t dark:border-gray-700 flex justify-end">
                <button onClick={handleResetFilters} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none dark:bg-gray-700 dark:text-gray-200 dark:border-gray-600 dark:hover:bg-gray-600">
                    Reset All Filters
                </button>
            </div>
            <style>{`.input { appearance: none; background-color: #fff; border-radius: 0.375rem; border: 1px solid #D1D5DB; padding: 0.5rem 0.75rem; width: 100%; color: #111827; } .input:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; } .dark .input { background-color: #374151; border-color: #4B5563; color: #F9FAFB; }`}</style>
          </div>
        )}
      </div>

      {hasActiveFilters && (
        <div className="p-3 bg-primary-50/50 dark:bg-primary-900/20 rounded-lg border border-primary-200 dark:border-primary-500/30">
            <div className="flex flex-wrap items-center gap-2">
                <span className="text-sm font-medium text-gray-700 dark:text-gray-200 mr-2">Active Filters:</span>
                {filters.selectedBuildingIds.map(id => <FilterPill key={id} onRemove={() => removeFilter('selectedBuildingIds', id)}>{getBuildingName(id)}</FilterPill>)}
                {filters.selectedStatuses.map(s => <FilterPill key={s} onRemove={() => removeFilter('selectedStatuses', s)}>{s}</FilterPill>)}
                {filters.selectedProviderIds.map(id => <FilterPill key={id} onRemove={() => removeFilter('selectedProviderIds', id)}>{getProviderName(id)}</FilterPill>)}
                {filters.startDate && <FilterPill onRemove={() => removeFilter('startDate')}>From: {filters.startDate}</FilterPill>}
                {filters.endDate && <FilterPill onRemove={() => removeFilter('endDate')}>To: {filters.endDate}</FilterPill>}
                <button onClick={handleResetFilters} className="text-sm text-primary-600 dark:text-primary-300 hover:text-primary-800 dark:hover:text-primary-200 font-medium ml-auto px-2">
                    Clear All
                </button>
            </div>
        </div>
      )}

      <TaskSection title="One-Time Tasks" groupedTasks={groupedOneTimeTasks} />
      <TaskSection title="Recurring Tasks" groupedTasks={groupedRecurringTasks} />
      
      {taskForRequest && buildingForRequest && (
        <CreateRequestModal
          building={buildingForRequest}
          task={taskForRequest}
          providers={providers}
          onClose={() => setTaskForRequest(null)}
          onAddServiceRequest={onAddServiceRequest}
        />
      )}

      {deletingTask && (
        <ConfirmationModal
          isOpen={!!deletingTask}
          onClose={() => setDeletingTask(null)}
          onConfirm={handleConfirmDelete}
          title="Confirm Task Deletion"
          message={confirmDeleteMessage}
          confirmButtonText="Delete Task"
        />
      )}
    </div>
  );
};

export default MaintenanceTasksView;